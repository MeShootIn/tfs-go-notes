package main

import (
	"fmt"
	"runtime"
	"sync"
)

/*
WAITGROUP

* WaitGroup - примитива синхронизации. Мы не можем дождаться выполнения конкретной горутины, но можем использовать
счётчики
* Планировщик даёт определённое время (10 мс) на выполнение очередной горутины, иначе даёт управление следующей
* Порядок вызова горутин НЕ ОПРЕДЕЛЁН => в Go это не стек и не очередь, нет приоритетов, но возможно есть свой алгоритм
* Передавать WG ТОЛЬКО ПО УКАЗАТЕЛЮ, т.к. тогда будет декрементиться будет счётчик копии
* ВСЕГДА писать Add(...) ДО ЗАПУСКА горутины, т.к. может не быть гарантий, что горутина запустится
*/

func main() {
	runtime.GOMAXPROCS(1)
	var wg sync.WaitGroup // Создаём счётчик
	wg.Add(2)             // Кол-во горутин, которые должны выполниться
	fmt.Println("Starting...")

	go func() {
		defer wg.Done() // Декремент счётчика. Если не сделать, то возникнет deadlock
		for char := 'a'; char < 'a'+26; char++ {
			// runtime.Gosched() // Заставляет планировщик передать управление другой горутине до следующего момента
			fmt.Printf("%c ", char)
			// time.Sleep(150 * time.Nanosecond)
		}
	}()

	go func() {
		defer wg.Done()
		for char := 'A'; char < 'A'+26; char++ {
			// runtime.Gosched() // 1
			fmt.Printf("%c ", char)
			// time.Sleep(150 * time.Nanosecond)
		}
	}()

	wg.Wait() // Блокирующая операция
	// Не видно параллелизма, т.к. каждая горутина отработала за <= 10 мс
	fmt.Println("\nFinished")
}
