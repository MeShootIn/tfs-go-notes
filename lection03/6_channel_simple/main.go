package main

import (
	"fmt"
	"sync"
)

/*
ОБЫЧНЫЕ (НЕБУФЕРИЗОВАННЫЕ) КАНАЛЫ

* Это так же является примитивом синхронизации
* Нужны для передачи данных из одной работающей горутины в другую
* Работает по принципу FIFO. Схема: запись, чтение, запись, чтение...
* Операции чтения и записи В КАНАЛ - БЛОКИРУЮЩИЕ операции. Т.е. операция чтения/записи блокирует всю горутину в месте
операции, пока никто не будет записывать/читать из канала, и передаёт управление планировщику, который передаёт
управление другой горутине. НО чтение из закрытого канала - НЕБЛОКИРУЮЩАЯ операция! А запись в закрытый
канал вызовет panic => ЗАКРЫВАТЬ канал должен тот, кто в него ПИШЕТ!
*/

func main() {
	unbuffered := make(chan string)
	wg := sync.WaitGroup{}

	wg.Add(1) // Писать ДО ЗАПУСКА горутины, т.к. может не быть гарантий, что горутина запустится
	go func() {
		defer wg.Done()
		for {
			// Если канал закрыт => ok == false и в канал точно ничего не может быть записано
			v, ok := <-unbuffered
			if !ok {
				fmt.Println("stop reader")
				return
			}

			fmt.Println(v)
		}
	}()

	wg.Add(1)
	go func() {
		defer wg.Done()
		for i := 0; i <= 9; i++ {
			// Операция записи блокирует всю горутину, пока никто не будет читать из канала, и передаёт управление
			// планировщику, который передаёт управление другой горутине
			unbuffered <- fmt.Sprintf("Hello #%d", i) // Отправляем в канал строку
		}

		close(unbuffered) // Если не закрыть канал, а все горутины заблокированы, т.е. планировщику некому дать
		// управление, тогда произойдёт deadlock (тип ошибки - fatal error)
	}()

	wg.Wait()

	// Часто встречающийся приём (используется свойство, что чтение/запись - блокирующие операции):
	done := make(chan struct{})

	go func() {
		// Какие-то действия...
		close(done)
	}()

	<-done // Операция чтения, которая разблокируется, когда вызовется close(done)
}
