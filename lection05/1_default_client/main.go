package main

import (
	"fmt"
	"io"
	"net/http"
)

/*
HTTP

* HTTP (HyperText Transfer Protocol):
1) Текстовый протокол передачи данных прикладного уровня. Нужен для сетевого общения между приложениями.
2) Режим "запрос-ответ".
3) Stateless - сервер не хранит контексты предыдущих запросов
* HTTPS (HTTP Secured) - HTTP, работающий через шифрование по SSL или TLS (алгоритмы асинхронного шифрования - можно
зашифровать, но нельзя расшифровать)

* OSI model (Open Systems Interconnection model) - уровни (слои) сетевого взаимодействия:
7) Application
6) Presentation
5) Session
4) Transport
3) Network
2) Data Link
1) Physical

* Структура для запроса и ответа:
TODO

* Заголовки - key-value значения: есть основные, есть кастомные
* Методы (регистрозависимы):
1) GET - получить (параметры в path/query)
2) POST - создать (параметрыи в body)
3) PUT, PATCH - изменить
4) DELETE - удалить
5) OPTIONS - проверить доступные методы (показывает, какие методы допустимо использовать на данном эндпоинте). Часто
используется на фронте
...
* Идемпотентность (<=> детерминированность) - свойство метода возвращать на один и тот же запрос - один и тот же ответ.
GET, PUT, DELETE, OPTIONS - наиболее идемпотентные (из представленных), остальные - нет.
* Коды ответа: TODO
1) 1xx - информационные (101 Switching Protocols - надо переключиться на другой протокол)
2) 2xx - успех (200 OK, 201 Created, 202 Accepted)
3) 3xx - перенаправление (301 Moved Permanently - перемещено навсегда)
4) 4xx - ошибка на стороне клиента (400 Bad request, 401 Unauthorized, 404 Not Found, 418 I'm a teapot, 451 Unavailable
For Legal Reasons - недоступно по юридическим причинам)
5) 5xx - ошибка сервера (500 Internal Server Error)
*/

/*
REST

* REST (REpresentational State Transfer) - архитектурный стиль взаимодействия компонентов сетевого приложения
* Требования:
1) Модель "клиент-сервер"
2) Stateless
3) Кэширование (необязательно, но возможно у идемпотентных методов)
4) Единообразие интерфейса TODO в википедии
5) Слои для удобства горизонтальной масштабируемости (например, controller-service-DAO)
6) Код по требованию (необязательно) - возможность отправлять вместо ресурсов приложения или скрипты

* Преимущества:
** Надёжность
** Производительность (за счёт кэширования)
** Масштабируемость
** Простота

* Недостатки:
** Взаимодействия синхронного типа "запрос-ответ"
** Вопрос производительности из-за TCP => не подходит для передачи больших данных
** Текстовый протокол

* Для документации - "swaggo/swag"
*/

func main() {
	_ = http.Request{
		Method: "",
		URL:    nil,
		Header: nil,
		Body:   nil,
	}

	_ = http.Response{
		Status:     "",
		StatusCode: 0,
		Header:     nil,
		Body:       nil,
	}

	// Слишком "простые" методы
	resp, err := http.Get("http://google.com/robots.txt")
	if err != nil {
		panic(err)
	}

	// Обязательно, если будем читать body
	defer resp.Body.Close()
	data, err := io.ReadAll(resp.Body)
	if err != nil {
		panic(err)
	}

	fmt.Println(string(data))
}
