package lecture07

import (
	"fmt"
	"math"
)

/*
ТЕСТИРОВАНИЕ

* Это регулярный процесс проверки ПО на соответствие реальным и ожидаемым результатам.
* Варианты тестирования:
1) TDD (Test Driven Development) - разработка через тестирование: сначала тесты, потом код.
2) Проверка соответствия ожиданиям - наоборот.
3) Проверка на регрессии - пишется тест, воспроизводящий ошибку, которую не учли ранее.

* Виды тестов:
1) Функциональные (проверяют функциональность):
1.1) Модульные (unit) - для тестирования "модулей" кода: функций и их композиций. Самые низкоуровневые.
1.2) Интеграционные - тесты, взаимодействующих друг с другом компонент.
1.3) Приёмочные и UI - странные вещи, которые может сделать пользователь.
2) Нефункциональные:
2.1) Производительность - скорость.
2.2) Надёжность (отказоустойчивость) - кончилось место на диске, сервер с БД перезапустился...
2.3) Удобство пользования, UX, ...
3) Связанные с изменениями:
3.1*) Регрессионные - чтобы не ломалось то, что было раньше реализовано. Могут быть:
** Функциональными
** Нефункциональными
*/

/*
МОДУЛЬНЫЕ (UNIT) ТЕСТЫ

* Unit-тесты "из коробки" (в Goland - файлы подсвечены зелёным фоном). Чтобы Go и IDE понимали, что файл тестовый:
1) Общий пакет
2) *_test.go - файл
3) import "testing"
4) Test* - имена функций
5) *testing.T - в сигнатурах

* Команда: go test [-v] ["./path"] (по умолчанию ищет только в текущей папке, а во всех уровнях ниже - "./...").
*/

/*
НАПОЛНЕНИЕ ТЕСТАМИ

* Команда: go test -cover (количество строк бизнес-логики кода было выполнено при исполнении тестов).
* go test с параметром компилирует свой бинарник со "своим" main'ом. А с параметром -cover в код тестов "добавляются"
счётчики кол-ва входов в определённые строки (при каждом входе счётчик инкрементится), что формирует % покрытия.
* В Goland: ПКМ -> More Run/Debug -> Run with Coverage - полная статистика.
* go test -cover -coverprofile=coverage.out ./... && go tool cover -func=coverage.out
*/

/*
АВТОМАТИЗАЦИЯ

* В Go встроен самый минимальный статический анализатор кода go vet, который автоматически запускается при go build.
* golangci-lint - агрегатор линтеров. Не запускает каждый линтер бинарником по отдельности, а оптимизированно согласует
работу всех линтеров и строит своё дерево анализа.
*/

func Int2Str(val int) string {
	return fmt.Sprint(val)
}

func Int2StrWrong(val int) string {
	if val == -1 || val == math.MaxInt16 {
		return `0`
	}
	return fmt.Sprint(val)
}

func Str2Int(val string) (res int) {
	_, _ = fmt.Sscan(val, &res)
	return
}
